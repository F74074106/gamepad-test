<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>手感精修版 V21</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #5c8aae; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <script>
        // --- 1. 場景設定 ---
        const scene = new THREE.Scene();
        const skyColor = 0x5c8aae;
        scene.background = new THREE.Color(skyColor);
        scene.fog = new THREE.Fog(skyColor, 50, 300);

        // --- 2. 地面與網格 ---
        const groundGeo = new THREE.PlaneGeometry(4000, 4000);
        const groundMat = new THREE.MeshBasicMaterial({ color: 0x356e35 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2; 
        scene.add(ground);

        const gridHelper = new THREE.GridHelper(4000, 200, 0x000000, 0x000000);
        gridHelper.material.opacity = 0.2; 
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        // --- 3. 雙圓軌道 (半徑 14) ---
        function createCircleTrack(centerX, centerZ, radius) {
            const trackWidth = 4;
            const segments = 150;
            const positions = [];
            const indices = [];

            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * Math.PI * 2;
                const x = Math.cos(t);
                const z = Math.sin(t);
                const outerX = centerX + x * (radius + trackWidth / 2);
                const outerZ = centerZ + z * (radius + trackWidth / 2);
                const innerX = centerX + x * (radius - trackWidth / 2);
                const innerZ = centerZ + z * (radius - trackWidth / 2);

                positions.push(outerX, 0.02, outerZ);
                positions.push(innerX, 0.02, innerZ);

                if (i < segments) {
                    const base = i * 2;
                    indices.push(base, base + 1, base + 2);
                    indices.push(base + 1, base + 3, base + 2);
                }
            }
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setIndex(indices);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
            return new THREE.Mesh(geometry, material);
        }

        const radius = 15; 
        scene.add(createCircleTrack(radius, 0, radius));   
        scene.add(createCircleTrack(-radius, 0, radius));  

        // --- 4. 相機設定 ---
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 30);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 5. 主角方塊結構 ---
        const physicsBody = new THREE.Group();
        physicsBody.position.y = 1;
        scene.add(physicsBody);

        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshNormalMaterial(); 
        const visualBody = new THREE.Mesh(geometry, material); 
        physicsBody.add(visualBody); 

        const noseGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const noseMat = new THREE.MeshBasicMaterial({ color: 0xff4444 }); 
        const nose = new THREE.Mesh(noseGeo, noseMat);
        nose.position.z = -1; 
        visualBody.add(nose);


        // --- 6. 物理核心 (V21 手感調整) ---
        const velocity = { x: 0, y: 0, z: 0, rot: 0 };

        // [修改 1] 加速度全面調降 (讓最大桿量更溫柔)
        // 這些數值越小，推到底時累積速度越慢，極速也越低
        const accMove = 0.012;      // 原 0.015 -> 0.012
        const accVertical = 0.008;  // 原 0.01  -> 0.008
        const accRotate = 0.0035;   // 原 0.005 -> 0.0035

        const frictionMove = 0.96;     
        const frictionVertical = 0.92; 
        const frictionRotate = 0.92;   

        const maxRollAngle = 0.6;  
        const maxPitchAngle = 0.3; 
        const bankLerp = 0.1;
        const yawBankFactor = 12; 

        const deadzone = 0.2; 
        
        // [修改 2] 曲線更趨近線性 (讓最小桿量更明顯)
        // 從 1.6 降到 1.2，這會讓起步反應變快，更有力
        const sensitivityCurve = 1.2; 

        let gamepadIndex = null;

        function getFineControlValue(rawValue) {
            if (Math.abs(rawValue) < deadzone) return 0;
            let percentage = (Math.abs(rawValue) - deadzone) / (1 - deadzone);
            percentage = Math.pow(percentage, sensitivityCurve);
            return percentage * Math.sign(rawValue);
        }

        window.addEventListener("gamepadconnected", (e) => {
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
            }
        });

        function animate() {
            requestAnimationFrame(animate);

            let targetRoll = 0;
            let targetPitch = 0;

            if (gamepadIndex !== null) {
                const gamepads = navigator.getGamepads();
                const gp = gamepads[gamepadIndex];

                if (gp) {
                    const valLeftX = getFineControlValue(gp.axes[0]); 
                    const valLeftY = getFineControlValue(gp.axes[1]); 
                    const valRightX = getFineControlValue(gp.axes[2]); 
                    const valRightY = getFineControlValue(gp.axes[3]); 

                    // 1. 旋轉與升降
                    if (valLeftX !== 0) velocity.rot -= valLeftX * accRotate;
                    if (valLeftY !== 0) velocity.y -= valLeftY * accVertical;

                    // 2. 水平移動
                    const yaw = physicsBody.rotation.y;
                    const forwardX = -Math.sin(yaw);
                    const forwardZ = -Math.cos(yaw);
                    const rightX = Math.cos(yaw);
                    const rightZ = -Math.sin(yaw); 

                    // 前後移動
                    if (valRightY !== 0) {
                        const thrust = -valRightY * accMove; 
                        velocity.x += forwardX * thrust;
                        velocity.z += forwardZ * thrust;
                        targetPitch = valRightY * maxPitchAngle;
                    }

                    // 左右平移
                    if (valRightX !== 0) {
                        velocity.x += rightX * valRightX * accMove;
                        velocity.z += rightZ * valRightX * accMove;
                    }

                    // 側傾計算
                    targetRoll = (velocity.rot * yawBankFactor) - (valRightX * maxRollAngle);
                }
            }

            // 摩擦力
            velocity.x *= frictionMove;
            velocity.z *= frictionMove;
            velocity.y *= frictionVertical;
            velocity.rot *= frictionRotate;

            // 更新位置
            physicsBody.rotation.y += velocity.rot;
            physicsBody.position.y += velocity.y;
            physicsBody.position.x += velocity.x;
            physicsBody.position.z += velocity.z;

            if (physicsBody.position.y < 1) { 
                physicsBody.position.y = 1;
                velocity.y = 0; 
            }

            // 更新視覺
            targetRoll = Math.max(-maxRollAngle, Math.min(maxRollAngle, targetRoll));
            targetPitch = Math.max(-maxPitchAngle, Math.min(maxPitchAngle, targetPitch));

            visualBody.rotation.z += (targetRoll - visualBody.rotation.z) * bankLerp;
            visualBody.rotation.x += (targetPitch - visualBody.rotation.x) * bankLerp;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>